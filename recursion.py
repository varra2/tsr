import numpy as np
#from datetime import datetime  #для оценки времени вычисления

#для теста
# 0,2 2,5 5,2 6,6 8,3
# 0,1 1,4 7,2 4,1 5,5
# 0,1 0,5 0,2 0,4 0,3
# 0,1 0,3 0,4 0,2 0,5
# 0,1 0,20 0,3 0,4 0,5 0,6 0,7 0,8 0,9 0,10 0,15 0,32 0,11
# 0,1
# 0,0 1,1 2,2

# Получение координат точек от пользователя
while True:
    print(
        "Пожалуйста, введите координаты всех точек через пробел попарно без скобок, как это указано в примере",
        "Пример: 0,2 2,5 5,2 6,6 8,3", sep="\n")
    try:
        # Заносим введённые пользователем координаты точек в список
        dots = input("Ваши данные: ").split(' ')
        # Проходимся по точкам из списка и переводим их в нужный формат
        for i, dot in enumerate(dots):
            nums = dot.split(',')
            dots[i] = int(nums[0]),int(nums[1])
        # Если всё прошло удачно - выходим из цикла
        break
    # Если всё идёт совсем неудачно, из программы можно выйти
    except KeyboardInterrupt:
        break
    except:
        print("Что-то пошло не так, пожалуйста, попробуйте ещё раз")

# Количество точек заношу в отдельную переменную, чтобы не считать заного каждый раз, как понадобится
lendots = len(dots)

# функция для расчёта расстояния между точками
def distance(point_1, point_2):
    return np.sqrt((point_2[0] - point_1[0]) ** 2 + (point_2[1] - point_1[1]) ** 2)

# Массив хранит расстояния между каждыми двумя точками
distances = np.empty([lendots, lendots])
for i in range(lendots):
    for j in range(lendots):
        distances[i,j] = distance(dots[i],dots[j])

# Начальное значение "оптимального пути" задаётся таким, что любое расстояние из возможных его не превысит
optway = np.sum(np.amax(distances, axis=0))+np.amax(distances[0])
# Начальный путь - пуст
path = []

#Номера пунктов, доступных для выбора первой (не нулевой) точки маршрута заносятся в сет
choice1 = set(range(1,lendots))

# Функция tsp берёт на вход сет с индексами доступных для выбора точек маршрута,
# список с индексами уже пройденных точек и длину пройденного пути
def tsp(dots, prev, way):
# У функции есть доступ к глобальным переменным optway и path
    global optway
    global path
    # Выбирается следующая точка пути
    for dot in dots:
        # В пройденное расстояние добавляется промежуток между предыдущей и новой точкой
        way += distances[prev[-1], dot]
        # В случае, если полученное расстояние превышает длину нынешнего "оптимального пути" - отбрасываем этот вариант
        if way >= optway:
            return
        # Если в сете осталась только одна точка - путь пройден,
        # добавляем расстояние от последней точки до пункта отправления в пройденный путь и проверяем, не найден ли новый оптимум
        # (в этом случае обновляем взначения глобальных переменных,
        #  внося длину пути в переменную optway и список пройденных пунктов в path)
        elif len(dots) == 1:
            way += distances[dot,0]
            if way<optway:
                optway = way
                path = prev+[dot,0]
            way -= distances[dot,0]
            return
        # Если продолжается движение по данному пути, определяем оставшиеся для выбора пункты
        nextchoice = dots.difference({dot})
        # Чтобы сделать следующий "шаг", функция вызывает сама себя, передав в качестве аргументов 
        # сет с номерами оставшихся для выбора пунктов, список пройденных пунктов, включая добавленный на данном шаге,
        # и обновлённую длину пути 
        tsp(nextchoice, prev+[dot], way)
        # Прежде чем закончить перебор и вернуться к предыдущему шагу, откатываем пройденное расстояние на шаг назад
        way -= distances[prev[-1], dot]

#print(f"Время до запуска: {datetime.now():%M:%S}")
tsp(choice1, [0], 0)
#print(f"Время после запуска: {datetime.now():%M:%S}")

# Формирование строки для ответа
answer = f"{dots[0]}"
length = 0
for i,v in enumerate(path[1:]):
    length += distances[path[i], path[i+1]]
    answer += f" -> {dots[v]} [{length}]"
answer += f" = {length}"

print(answer)